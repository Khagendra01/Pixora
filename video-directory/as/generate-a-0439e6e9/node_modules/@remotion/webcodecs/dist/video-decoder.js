"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createVideoDecoder = exports.internalCreateVideoDecoder = void 0;
const io_synchronizer_1 = require("./io-manager/io-synchronizer");
const log_1 = require("./log");
const internalCreateVideoDecoder = ({ onFrame, onError, controller, config, logLevel, }) => {
    const ioSynchronizer = (0, io_synchronizer_1.makeIoSynchronizer)({
        logLevel,
        label: 'Video decoder',
        controller,
    });
    const videoDecoder = new VideoDecoder({
        async output(frame) {
            try {
                await onFrame(frame);
            }
            catch (err) {
                onError(err);
                frame.close();
            }
            ioSynchronizer.onOutput(frame.timestamp);
        },
        error(error) {
            onError(error);
        },
    });
    const close = () => {
        if (controller) {
            controller._internals._mediaParserController._internals.signal.removeEventListener('abort', 
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            onAbort);
        }
        if (videoDecoder.state === 'closed') {
            return;
        }
        videoDecoder.close();
    };
    const onAbort = () => {
        close();
    };
    if (controller) {
        controller._internals._mediaParserController._internals.signal.addEventListener('abort', onAbort);
    }
    videoDecoder.configure(config);
    const decode = (sample) => {
        if (videoDecoder.state === 'closed') {
            return;
        }
        const encodedChunk = sample instanceof EncodedVideoChunk
            ? sample
            : new EncodedVideoChunk(sample);
        videoDecoder.decode(encodedChunk);
        ioSynchronizer.inputItem(sample.timestamp);
    };
    return {
        decode,
        waitForFinish: async () => {
            await videoDecoder.flush();
            log_1.Log.verbose(logLevel, 'Flushed video decoder');
            await ioSynchronizer.waitForFinish();
            log_1.Log.verbose(logLevel, 'IO synchro finished');
        },
        close,
        flush: async () => {
            await videoDecoder.flush();
        },
        waitForQueueToBeLessThan: ioSynchronizer.waitForQueueSize,
    };
};
exports.internalCreateVideoDecoder = internalCreateVideoDecoder;
const createVideoDecoder = ({ onFrame, onError, controller, track, logLevel, }) => {
    return (0, exports.internalCreateVideoDecoder)({
        onFrame,
        onError,
        controller: controller ?? null,
        config: track,
        logLevel: logLevel ?? 'info',
    });
};
exports.createVideoDecoder = createVideoDecoder;
