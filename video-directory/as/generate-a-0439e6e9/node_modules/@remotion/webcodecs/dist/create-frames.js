"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractFrames = void 0;
const media_parser_1 = require("@remotion/media-parser");
const worker_1 = require("@remotion/media-parser/worker");
const create_video_decoder_1 = require("./create-video-decoder");
const extractFrames = async ({ fromSeconds, toSeconds, width, height, src, onFrame, }) => {
    const controller = (0, media_parser_1.mediaParserController)();
    controller.seek(fromSeconds);
    const segmentDuration = toSeconds - fromSeconds;
    const expectedFrames = [];
    try {
        await (0, worker_1.parseMediaOnWebWorker)({
            src: new URL(src, window.location.href).toString(),
            acknowledgeRemotionLicense: true,
            controller,
            onVideoTrack: ({ track }) => {
                const aspectRatio = track.width / track.height;
                const framesFitInWidth = Math.ceil(width / (height * aspectRatio));
                const timestampTargets = [];
                for (let i = 0; i < framesFitInWidth; i++) {
                    timestampTargets.push(fromSeconds +
                        ((segmentDuration * media_parser_1.WEBCODECS_TIMESCALE) / framesFitInWidth) *
                            (i + 0.5));
                }
                const decoder = (0, create_video_decoder_1.createVideoDecoder)({
                    onFrame: (frame) => {
                        if (frame.timestamp >= expectedFrames[0] - 1) {
                            expectedFrames.shift();
                            onFrame(frame);
                        }
                        frame.close();
                    },
                    onError: console.error,
                    track,
                });
                const queued = [];
                return async (sample) => {
                    const nextTimestampWeWant = timestampTargets[0];
                    if (nextTimestampWeWant === undefined) {
                        throw new Error('this should not happen');
                    }
                    if (sample.type === 'key') {
                        queued.length = 0;
                    }
                    queued.push(sample);
                    if (sample.timestamp > nextTimestampWeWant) {
                        expectedFrames.push(timestampTargets.shift());
                        while (queued.length > 0) {
                            const sam = queued.shift();
                            await decoder.waitForQueueToBeLessThan(10);
                            await decoder.decode(sam);
                        }
                        if (timestampTargets.length === 0) {
                            await decoder.flush();
                            controller.abort();
                        }
                    }
                };
            },
        });
    }
    catch (e) {
        if (!(0, media_parser_1.hasBeenAborted)(e)) {
            throw e;
        }
    }
};
exports.extractFrames = extractFrames;
